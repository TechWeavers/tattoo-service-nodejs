"use strict";
const punycode = require("punycode");
const tr46 = require("tr46");

const specialSchemes = {
  ftp: 21,
  file: null,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};

const failure = Symbol("failure");

function countSymbols(str) {
  return punycode.ucs2.decode(str).length;
}

function at(input, idx) {
  const c = input[idx];
  return isNaN(c) ? undefined : String.fromCodePoint(c);
}

function isASCIIDigit(c) {
  return c >= 0x30 && c <= 0x39;
}

function isASCIIAlpha(c) {
  return (c >= 0x41 && c <= 0x5A) || (c >= 0x61 && c <= 0x7A);
}

function isASCIIAlphanumeric(c) {
  return isASCIIAlpha(c) || isASCIIDigit(c);
}

function isASCIIHex(c) {
  return isASCIIDigit(c) || (c >= 0x41 && c <= 0x46) || (c >= 0x61 && c <= 0x66);
}

function isSingleDot(buffer) {
  return buffer === "." || buffer.toLowerCase() === "%2e";
}

function isDoubleDot(buffer) {
  buffer = buffer.toLowerCase();
  return buffer === ".." || buffer === "%2e." || buffer === ".%2e" || buffer === "%2e%2e";
}

function isWindowsDriveLetterCodePoints(cp1, cp2) {
  return isASCIIAlpha(cp1) && (cp2 === 58 || cp2 === 124);
}

function isWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && (string[1] === ":" || string[1] === "|");
}

function isNormalizedWindowsDriveLetterString(string) {
  return string.length === 2 && isASCIIAlpha(string.codePointAt(0)) && string[1] === ":";
}

function containsForbiddenHostCodePoint(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|%|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function containsForbiddenHostCodePointExcludingPercent(string) {
  return string.search(/\u0000|\u0009|\u000A|\u000D|\u0020|#|\/|:|\?|@|\[|\\|\]/) !== -1;
}

function isSpecialScheme(scheme) {
  return specialSchemes[scheme] !== undefined;
}

function isSpecial(url) {
  return isSpecialScheme(url.scheme);
}

function defaultPort(scheme) {
  return specialSchemes[scheme];
}

function percentEncode(c) {
  let hex = c.toString(16).toUpperCase();
  if (hex.length === 1) {
    hex = "0" + hex;
  }

  return "%" + hex;
}

function utf8PercentEncode(c) {
  const buf = new Buffer(c);

  let str = "";

  for (let i = 0; i < buf.length; ++i) {
    str += percentEncode(buf[i]);
  }

  return str;
}

function utf8PercentDecode(str) {
  const input = new Buffer(str);
  const output = [];
  for (let i = 0; i < input.length; ++i) {
    if (input[i] !== 37) {
      output.push(input[i]);
    } else if (input[i] === 37 && isASCIIHex(input[i + 1]) && isASCIIHex(input[i + 2])) {
      output.push(parseInt(input.slice(i + 1, i + 3).toString(), 16));
      i += 2;
    } else {
      output.push(input[i]);
    }
  }
  return new Buffer(output).toString();
}

function isC0ControlPercentEncode(c) {
  return c <= 0x1F || c > 0x7E;
}

const extraPathPercentEncodeSet = new Set([32, 34, 35, 60, 62, 63, 96, 123, 125]);
function isPathPercentEncode(c) {
  return isC0ControlPercentEncode(c) || extraPathPercentEncodeSet.has(c);
}

const extraUserinfoPercentEncodeSet =
  new Set([47, 58, 59, 61, 64, 91, 92, 93, 94, 124]);
function isUserinfoPercentEncode(c) {
  return isPathPercentEncode(c) || extraUserinfoPercentEncodeSet.has(c);
}

function percentEncodeChar(c, encodeSetPredicate) {
  const cStr = String.fromCodePoint(c);

  if (encodeSetPredicate(c)) {
    return utf8PercentEncode(cStr);
  }

  return cStr;
}

function parseIPv4Number(input) {
  let R = 10;

  if (input.length >= 2 && input.charAt(0) === "0" && input.charAt(1).toLowerCase() === "x") {
    input = input.substring(2);
    R = 16;
  } else if (input.length >= 2 && input.charAt(0) === "0") {
    input = input.substring(1);
    R = 8;
  }

  if (input === "") {
    return 0;
  }

  const regex = R === 10 ? /[^0-9]/ : (R === 16 ? /[^0-9A-Fa-f]/ : /[^0-7]/);
  if (regex.test(input)) {
    return failure;
  }

  return parseInt(input, R);
}

function parseIPv4(input) {
  const parts = input.split(".");
  if (parts[parts.length - 1] === "") {
    if (parts.length > 1) {
      parts.pop();
    }
  }

  if (parts.length > 4) {
    return input;
  }

  const numbers = [];
  for (const part of parts) {
    if (part === "") {
      return input;
    }
    const n = parseIPv4Number(part);
    if (n === failure) {
      return input;
    }

    numbers.push(n);
  }

  for (let i = 0; i < numbers.length - 1; ++i) {
    if (numbers[i] > 255) {
      return failure;
    }
  }
  if (numbers[numbers.length - 1] >= Math.pow(256, 5 - numbers.length)) {
    return failure;
  }

  let ipv4 = numbers.pop();
  let counter = 0;

  for (const n of numbers) {
    ipv4 += n * Math.pow(256, 3 - counter);
    ++counter;
  }

  return ipv4;
}

function serializeIPv4(address) {
  let output = "";
  let n = address;

  for (let i = 1; i <= 4; ++i) {
    output = String(n % 256) + output;
    if (i !== 4) {
      output = "." + output;
    }
    n = Math.floor(n / 256);
  }

  return output;
}

function parseIPv6(input) {
  const address = [0, 0, 0, 0, 0, 0, 0, 0];
  let pieceIndex = 0;
  let compress = null;
  let pointer = 0;

  input = punycode.ucs2.decode(input);

  if (input[pointer] === 58) {
    if (input[pointer + 1] !== 58) {
      return failure;
    }

    pointer += 2;
    ++pieceIndex;
    compress = pieceIndex;
  }

  while (pointer < input.length) {
    if (pieceIndex === 8) {
      return failure;
    }

    if (input[pointer] === 58) {
      if (compress !== null) {
        return failure;
      }
      ++pointer;
      ++pieceIndex;
      compress = pieceIndex;
      continue;
    }

    let value = 0;
    let length = 0;

    while (length < 4 && isASCIIHex(input[pointer])) {
      value = value * 0x10 + parseInt(at(input, pointer), 16);
      ++pointer;
      ++length;
    }

    if (input[pointer] === 46) {
      if (length === 0) {
        return failure;
      }

      pointer -= length;

      if (pieceIndex > 6) {
        return failure;
      }

      let numbersSeen = 0;

      while (input[pointer] !== undefined) {
        let ipv4Piece = null;

        if (numbersSeen > 0) {
          if (input[pointer] === 46 && numbersSeen < 4) {
            ++pointer;
          } else {
            return failure;
          }
        }

        if (!isASCIIDigit(input[pointer])) {
          return failure;
        }

        while (isASCIIDigit(input[pointer])) {
          const number = parseInt(at(input, pointer));
          if (ipv4Piece === null) {
            ipv4Piece = number;
          } else if (ipv4Piece === 0) {
            return failure;
          } else {
            ipv4Piece = ipv4Piece * 10 + number;
          }
          if (ipv4Piece > 255) {
            return failure;
          }
          ++pointer;
        }

        address[pieceIndex] = address[pieceIndex] * 0x100 + ipv4Piece;

        ++numbersSeen;

        if (numbersSeen === 2 || numbersSeen === 4) {
          ++pieceIndex;
        }
      }

      if (numbersSeen !== 4) {
        return failure;
      }

      break;
    } else if (input[pointer] === 58) {
      ++pointer;
      if (input[pointer] === undefined) {
        return failure;
      }
    } else if (input[pointer] !== undefined) {
      return failure;
    }

    address[pieceIndex] = value;
    ++pieceIndex;
  }

  if (compress !== null) {
    let swaps = pieceIndex - compress;
    pieceIndex = 7;
    while (pieceIndex !== 0 && swaps > 0) {
      const temp = address[compress + swaps - 1];
      address[compress + swaps - 1] = address[pieceIndex];
      address[pieceIndex] = temp;
      --pieceIndex;
      --swaps;
    }
  } else if (compress === null && pieceIndex !== 8) {
    return failure;
  }

  return address;
}

function serializeIPv6(address) {
  let output = "";
  const seqResult = findLongestZeroSequence(address);
  const compress = seqResult.idx;
  let ignore0 = false;

  for (let pieceIndex = 0; pieceIndex <= 7; ++pieceIndex) {
    if (ignore0 && address[pieceIndex] === 0) {
      continue;
    } else if (ignore0) {
      ignore0 = false;
    }

    if (compress === pieceIndex) {
      const separator = pieceIndex === 0 ? "::" : ":";
      output += separator;
      ignore0 = true;
      continue;
    }

    output += address[pieceIndex].toString(16);

    if (pieceIndex !== 7) {
      output += ":";
    }
  }

  return output;
}

function parseHost(input, isSpecialArg) {
  if (input[0] === "[") {
    if (input[input.length - 1] !== "]") {
      return failure;
    }

    return parseIPv6(input.substring(1, input.length - 1));
  }

  if (!isSpecialArg) {
    return parseOpaqueHost(input);
  }

  const domain = utf8PercentDecode(input);
  const asciiDomain = tr46.toASCII(domain, false, tr46.PROCESSING_OPTIONS.NONTRANSITIONAL, false);
  if (asciiDomain === null) {
    return failure;
  }

  if (containsForbiddenHostCodePoint(asciiDomain)) {
    return failure;
  }

  const ipv4Host = parseIPv4(asciiDomain);
  if (typeof ipv4Host === "number" || ipv4Host === failure) {
    return ipv4Host;
  }

  return asciiDomain;
}

function parseOpaqueHost(input) {
  if (containsForbiddenHostCodePointExcludingPercent(input)) {
    return failure;
  }

  let output = "";
  const decoded = punycode.ucs2.decode(input);
  for (let i = 0; i < decoded.length; ++i) {
    output += percentEncodeChar(decoded[i], isC0ControlPercentEncode);
  }
  return output;
}

function findLongestZeroSequence(arr) {
  let maxIdx = null;
  let maxLen = 1; // only find elements > 1
  let currStart = null;
  let currLen = 0;

  for (let i = 0; i < arr.length; ++i) {
    if (arr[i] !== 0) {
      if (currLen > maxLen) {
        maxIdx = currStart;
        maxLen = currLen;
      }

      currStart = null;
      currLen = 0;
    } else {
      if (currStart === null) {
        currStart = i;
      }
      ++currLen;
    }
  }

  // if trailing zeros
  if (currLen > maxLen) {
    maxIdx = currStart;
    maxLen = currLen;
  }

  return {
    idx: maxIdx,
    len: maxLen
  };
}

function serializeHost(host) {
  if (typeof host === "number") {
    return serializeIPv4(host);
  }

  // IPv6 serializer
  if (host instanceof Array) {
    return "[" + serializeIPv6(host) + "]";
  }

  return host;
}

function trimControlChars(url) {
  return url.replace(/^[\u0000-\u001F\u0020]+|[\u0000-\u001F\u0020]+$/g, "");
}

function trimTabAndNewline(url) {
  return url.replace(/\u0009|\u000A|\u000D/g, "");
}

function shortenPath(url) {
  const path = url.path;
  if (path.length === 0) {
    return;
  }
  if (url.scheme === "file" && path.length === 1 && isNormalizedWindowsDriveLetter(path[0])) {
    return;
  }

  path.pop();
}

function includesCredentials(url) {
  return url.username !== "" || url.password !== "";
}

function cannotHaveAUsernamePasswordPort(url) {
  return url.host === null || url.host === "" || url.cannotBeABaseURL || url.scheme === "file";
}

function isNormalizedWindowsDriveLetter(string) {
  return /^[A-Za-z]:$/.test(string);
}

function URLStateMachine(input, base, encodingOverride, url, stateOverride) {
  this.pointer = 0;
  this.input = input;
  this.base = base || null;
  this.encodingOverride = encodingOverride || "utf-8";
  this.stateOverride = stateOverride;
  this.url = url;
  this.failure = false;
  this.parseError = false;

  if (!this.url) {
    this.url = {
      scheme: "",
      username: "",
      password: "",
      host: null,
      port: null,
      path: [],
      query: null,
      fragment: null,

      cannotBeABaseURL: false
    };

    const res = trimControlChars(this.input);
    if (res !== this.input) {
      this.parseError = true;
    }
    this.input = res;
  }

  const res = trimTabAndNewline(this.input);
  if (res !== this.input) {
    this.parseError = true;
  }
  this.input = res;

  this.state 
G’^|û’²d_¹QÃæ ­%iu«ê—[Çë†ğA(ÈGÜ%é:…”+ÙèZÁ<‚|„S1
{êu1&!ò
~’„—Ì‹QØ÷£^«âOÎö ³ÿ^[zu³nÏ5tº÷5¼´üÎF¾R‹¬bZ-ŞyM‰v:üêı€ÄÃb´&E—b
û}k*^0Ïyû¸ò-Ü±+Z¿£=Ö*‹ú!l]“è¶hñ–zÿ·÷”@Áö:ÿ>ŠR‹$›ñ4òV¾JÉÃH+”ïèqå©Ÿh±ï÷¨‹×Š„ÅÅD’è—P]\ZÒV‡_™ ¡'Æ¼ÃNÇéš½G2^'¿P9~¿51f€´âÆ{ÌŒ“ëU9»t¸»ºæÅŸt€¢óÌÆ_©)ìjßÅ¿Ğâ3‹Ğû‰¥”…ê…ÓZss áã|JUp	Hltÿ<[@Ajòİ<ïz)å¨íŞğ‡¼ÑiQÆr_{VÊmåM´Ö‰ÛŠDÒ>è‰Î|£Aõò¨š[yPIÍ¡ÓGšz}Wİ°Ó1jgñê§ò4MW‘@Öwj¡ƒ†ua'[V£p=›–SU*3NâGŠ@·ux9ÕãJ«µÙ‹¤‰îFó
’6²Ö›ÍçÉ „Û’VÁ†­–½ÍØs¤÷?¢b‚_T¨†$›Ù8£9ñÍèìu_#j~rÓ«#»¹í'…M·­¹FWøZìÑÓ•Õ\“.º|BØC~ÑÔšĞ# _©Eé'(ÈqÊo:µ\2*0‡@øÚr	–m!ªH½BæUsÃ!ÃUÑ:@·î¼l^—‚è$­ŠÖŞë"ÏŸåµ7H#œK`ıYÕªC'_¼Y]ŸØ×Ö¸Ÿï»LÌ%q’Lf»k¼gÙæ*Ê-HW” ='éo®|õø·:ÿ[u«A&–EŸQÚ2cè"f¤Ÿ)÷F´ıB{Â?,Õ]>ÀæCvX$®6­iŒ;vÉÚTŞ¯€ğÄùú„aıÿŒÑÌeuŸ¬âWºA(r¹K¦®7Ò²S=H#E´v†ÆóGtıd±Áö³!2íïíe.Íâ+æ_ÿhCcÌ&+ş>›{œ4	¢3¹W†ÆĞq¢_@¿$ò·¾Ò¬ßÈÈóïœo?{µ§Ò€Ôbj)–{Ö‡Dï8Z}1Æ\v—Ğ'}«K/?22†ÉâÉßosÙ‹„ñbE)Æ‹ÖérÒ’Îµäl¥arÌ,…nş’Si×ì~ˆK¢®LA˜åaÂ>G ¸[Š‚®¾¯ pû†OKäp „Ëø¢0†])_ÛHË'F ©^¾¡ AáJcp7mLk³5$„å74ÿ‹Ù**Î¥K}MuEJşH==Y_SiH¢Àñ}ÿGÓyÇõü}qüÓ Yá3ú$¥AÈş$	E4PJŠ„QJ!„”ºÉHF*DDBV2BöŞ”­¯]Vö¨ŒH~ï×9~ÿ|ÏÇã|î¾÷ÜsÏo…ªçæ™ìBşvHı
H?RÊ•w5‹ÍX?0–”H#–ôËY•¼âúËê5ŸÒÿû@—;@âI}6Ê1vµ]6›uH-Tb¹îûB-ÇX¯›=j-;œAtíšêwË™‹Ø‘_Øº’ŞÍøÏˆ"Ù6|+ûñ@ªSeDU8? ñŞI]ig%Ú|ëcêJGbvGòƒ- ¼¼Ğ˜ÒÔM¶Ô¹Ci‚ĞæU•(Ë­fr|‘|„şŸu¦ÿÎ4ıY§m¿Aºi|39Ü’ekÿŞ¯Oi„I•3L(Ssî½ãØ ˆú†Şßáƒ‰+¿†mç‹S IÃä‘X¹¯9eìè–Ã‹ù!*T¢çw7sj½p©—óÄÒˆß!]YÂRı1‡;ñ‚¤ã¾£Ÿ&Œ¶C‡çèrŒÍ"jÃn²õ· ‡¸i:TZF¤ÇD=à¸%•ç€ènÈ§K$Ò‰¿úŒéşVò1Y3ŸÍÊÜhÇš»’PŞÍÇV*ÎÍ;'‡´’Ów*÷_óàÍÆN­ŸÈñHÛÖr,Ú÷{äÇ±@aònÌ ½6T#,<ÈkS-1/·‘ë;jh½‘=†5‚½ÛşU7zó0ô‡ÉIXZÅ£$Uà`JpX“¶T˜[º¥ÿN(€Ôb#Ik5k'_›mQĞyÔÒ:ó¬!‰#?QV›öT½I+÷ìåÓZ ©¬UtY®²=¥<0«ğç„<yé ÷x=°dbØşi½ ñæ¼02T‹!UpvT\ê@u0uÃ™Áì¸ !\]›ãòåñ“Ù‘Ä¡£œYæ)øH>’ûNIÆœ7ßØ“Â€‚ÄÊãªÀÎ®´AË‹ş^DwãagJËû§ã!^Îƒˆ¯Uä~zlC}§Ã7•ûWAbÛ/Ğ1ºÈ×'ÊèëõKV·¯òöÈèæ»å]äÇœWµo¡O`Ôß!ZûÂ®òfêIšñMW‡CÒˆ¾¿©sDÛÉw/	Õ_;û¬—ª-K\¡‡˜EÒ:öÔùÚóIfĞ qá÷ÿ$Æm]9ä!äÕtYİS?wi£œ×G¹
$’ôãØj”eòª‡:ı€ ”Å¤#I^%Zîæg™@Ró_­&¿øğ^¤àÔZë÷±!
ªñšQÃøvbÁü¯Ü /)¥v7},ØÏj&ò%©œq3İp„ó€¤Šş`4ìp¦6¸±g´Û& š/;SÎ®¬tÏıDÛT©o}.¹v›oÿ€¤Âj× .Nj»ÉW¥…d9]¦=Ù~ÍÇBkÕö±nTÅÉ_fôgmR‹’FV¹Qª«3&<c½ò·HÚººŸ|®£®nŸ¦Ë>\$_H[xÿ’í‰oı—–µ	ı©ÖŒ|İäsù ñ@æ+Ù[¶‘ä0,Ãrÿ‹bÃD»z:îTõÚíæÛ° :"ÖÃ]ë!kºy/kK­´|%…Ôx±‡<â–û¶ÆÕÙ­è;(""í|»»$¹J¶ÂÈ‹
ğ²Ûü ii¡í+uk½¨B6},oÂŸB!Õ ã^4Õ?:»}7{PAREÏ‘v’™\$[|iÌËÊ‰d¨9¾Ÿ„€g’Ã$·}5q›ä QªìtõLÕsğb?w5Aâ;ê´‡eÖ/bd7Ö8 !nèBÚhç09)¼w¹Äß	ïZZùøË±aªİnz}6KAâIuN§â©;k;?fR½Ú¶k3BöYsí|>ñRsIj(ği„Ão|Xí/|¬$uãµQ‡uW”Ë'xen®÷ø¼†Fõ!Ëìá¨Š'GÊqçùš»½)Ã 8f¤€ÙñÒ‘Tù¿kØ…BÀõ¨Y>ñï€+º%”ß	TO=‡tc+$Dqmt‰ƒÑ£I!¸Ü»6•Ïs‚0GĞCèñ)chÛ•0S‡÷Ú@j1]Å9ó%FØÖ ¢´í„\v+/Ú•š÷ ·NhW²–@x‚¢İqrE{¶^}'¾äògô©ï[ÆËá†Èª·O—=ä ©qTò•ŞATs“?a·Hª«QuyÓ¼ j¿áSwğk— 1K’’Ó-¦qx8¯MA$PÉÆî¦<UæXÌä3º ¸@iíBiV_K,c(x¾ø%‰ˆõÏUe;?@R%¼ÕGÄ]nM–Ã«ıŸNõTşö'H²Íë!â^¹S(·Ié=¿roI…™_U<ºfŠÜøv‚ÇìGgÅìAƒPÅ×O¥€[uÛÚó5&pƒ°¾ìıŞ©ÔîWWßY­-fN”Lá;«ñ™!J602Be7ÀÆP>Çğy?¶~>ÑBj Ûõçn“§Qh·~ÍÙ’ ‰Zõ!í³p:) ¬U·ãØ(iDx}4ŸçÉé”±?CªÙò¡ù6×‡>¨õe:ú›÷?ÿ·‹'épŸ!ßÑsşµo“¢j; SJkøL©şØIyêtÏ®€u.H#,@šuv&Õ²Mä/=Şæy?’¶®™IÉ/·–|®¤[%©‘,P3‹b¾>8¯1o0hÓìld¹hí,&m­´y„,7¾7‹úEŒÿyŞZ©E%›óv–<+wÃv'«Îê?ƒä!4D¬'ÖÎ&² U‡'UùäÏ–ã:Ç†ãâ&‘¤#(\ß¢(
—9ûåuŞ¡!$0€~5<çmË—Ş$š/’¢“¢ÉTÿÚÆgÏ@0úåP0¿¦ÇP“Í7–=ƒ Ä¹nU]ıNowò›A úB·Êx¹:†–éVÎî9üH#F`k<x.Åëºàjo~WDñÎˆ•¯ˆØß,¨ª¿>}Ôµ£éÂº—ci$Fnÿ¶øƒ4"Í ¥/~G
xuşÃH6åA÷¥§cW*(ÈVÉ5iÄ%Êg¤n<wûøcü:H-~S¬ñÖñÔ)G)#²¹S‚køÖx9¼Ršw%éì•©…²bÍï4:{İ¦'ù=´(!©i‹ò"¸ÿXQ‹½ iQÒu£ë—@iÊ¶qš :Á4<jàc›ÃÍø
Ÿß	´tšRğøŸH-öI1êÈb'ÎwaNn¼Œı‹sE‘Z«^ÛÆwĞM’+‡¶óP°hcå"TÿÚ®¡ÎhÖæM¤Î"†4AŞÍI’ò5ğŞ÷/2şĞ¥²êµ˜$ImeÃ:-¡Î¿#tÿ¾Ğ¢QK¨‹:¶¼Ô`?ïÇKDÍŞYlAdí×u›Áv $~¯	´ÓœË(ó6Õãyç$YŸ(W=<—S§Ú<mäî  1D¦¼²)™*ïÇ—¶Ü}@HÛòe2å·Gûşlp2Ä	9bu^Ÿ*÷£¼mp«	.²&(ë¬Ü€ïjá¯€Tñ1•Ân¬Xø‚İ¾ i&$é_©4+Bœ¶óµdZ,S`p…K£â¬ù<ÜÏ<€£—Ò¨sØ©¸şŒê	„a¹CŠØ±%¥ê–x¸	û‚A’š~¬@Ê¹¸Š"6ÌjÛ˜g4íß^^E½=bAµ6Oû H²şcÉ)—‚"~Y¤J_¦²·•«È€Ù=¸eX2!ïl¶W¢ãh_^M=~`¯ [{ ¨w%ª"P{Å¿4¯×h6ÈA"…¤½ı×Êkı×.qãĞQ|h·~Ó”VñL‰òäÆdĞïjáÄo‚ºéüy½*“©K,^‹á°r.f8-Ş^^GaUA®ïTƒ2„\…
ÌZ¿róÇÜÊs
6{%1/9îİkô‘÷à@Áqâª
9İªµBş?Åw@AÂİñ.I+–ê†ûó5Ô0Ñ?>İH•´æ¢ê»DAtÊ²t£¼ıtu^«úcÓ'5@jQ&…/û™EÚ·æçîø „s¿‰ÄCOïÕéG$ó7Q˜˜—º^|à	DÎøÎÙÔ{f•Z_a£¤Zjpâ³lù¼µ+Î¨[İØÂ@a+Iİe“7“¯fÌ•ü<*±]¿™Æ—»~ŞsŞ+A¢2ØBsğ€Ïgjó“9 ©RBÕ°ezÎØ*ïS³xlıµı²ètƒî<7DÀ'E[yá9¡] ÷V´Û@9m26G®lv9`Èõ†#~ÓTáØ©÷sµxOÒûï¶Qùk-IÅH#jan?·|;9û÷±)*ãSÁÑ¶AO#/»¶æÌÍcú­t¤?€ÔÂ‡¤ıºï í7:™u4H-Â%éYÎ‘ò/n®œì8ÿåtîz¿sKš5œw’Ö
É>ÁŸÖ‘³aÒNrCœŠMîL}É¡&»ä–……ÎU±§ºğ£yŞK%­—HYÙg˜K:fQ‘½IÖ‘*wéÑ\ªÂ£S6ü=#¢İR•K	ö{¹æû=@ÁÚ¢ES_&0]Ï8xy°·$Ùˆ4•}pßMQ¾,’xì€x/Ç©)tÁœğ<9ö‹{—=îFQƒ ¾¶5Å(©ë±‡:`zÀå9<A€¤v}HâÍ{)>w¼zò!(”~kcX³t/…¶š²±åx>¶%ÑádŒ!¶6ç€üŒ£aãºÚ	ßÖ“{„Üù:ÀcşÉ«å7yÌK$DÛf¨(›ÒƒT=“liCy!ÜØC¤}ªKøDpO6Cn“Šä¡ÏßÄÄYıôğ|¼¸nœy$Ü“’8Vv»Ûy¸òÂ[Ã@½(zş{@åÚË{„ú‚å{Ïï`ƒ ÙQ|„ÔÄõMÿ}ÙA"Hj:%Ëáê»u³ø’‚İG©Vö^nÃ“ÈCt4A™Y—§œ®s‰¢i†ì"ÜQNv¯Ôb®	êÌşâqÒZóÆ¤á]|MÇ)'wGã—ä@j‘N±.˜t‚jt°Ìt2ÛN  ±¤ºSNS^«Ë»õä¼‚º
#Sß—óJJÊÎñüR‹¦ÈÍrë3Ô{–wútÎ…¯üI„ÜTş:CC:°îƒåìv	lŠôæo>Oõ¦“ÄÎ ‡xkŠ>¹BqA>|ÛÏfı§:|Xæ‹v¸”éı˜^¹hî«ã!;ëw‘Êb]á¯ËOÒ‚j¤ÿE2ZjµŞC$§F_¤:?ì”dÌş-vu5GIN*.É-¶Ÿîïúk¸ñ#úœ8!÷¸D*q°ììc~ˆ$ôÌP’yO.S­ßq–—J ˜b†É ÷ª«”ªÃ¥å?ùUab·ë*•áÉà.>üq$×‡^#Ií7n± AÒ+üÕéhYÁ<µ€Ôb³Jğéï5ùÖ7mzİ9à {‡-¢¨ôqtO$áÇuÒ¿o\üîÀ;ÁyˆfSÂŠä'®Œ(t(Ëjr?åQ"lš#Ú.7ÈCà8¬İ|~ĞDG¨îİ ìœ¶_»”›ä!z™ÃbÚwK3.:‹îx|äû´Ñ1Ÿõ·È@ùynÌJvp‚àÄJ6Çğ~uï5bYÑÈ»ø€D4¤¾ß’÷Xö2ì¤Uªå:b
^+¾›£-vEÜ!MQ4÷	kzF¤X@jwáµEêÁ‡¸`D?O¸Kí8û]]^‹ƒHÛO¾+¯>½»kïkİ”B’êGaé«sUL°¤ù-ª˜mRzä@^‚4¢s¨aı³År\t‹[ÉG€Ø$iğm´È"ÃnŸ‘¿•5‚fúäĞí«ZÄµ@%~ Çe¦°·o[ìäá"®
·€Íõ|öCJ|{ñ²®<÷‚}Ÿ%©ïÎJ«àãx Htı‘Í••Ú€]â ùñ…-0ù”Ê+~6}1ÂÃ1…Lp´Bvã<§xŸ})Ib3¤‹¬Ğë­yÎ½“¯?ó¬¢âîA’üºÿ^9A’oõ’ò³¯v´Ÿ~Ññ-ñ’Â”iòV³Ó ¤Ç('Û¢_‘ÆoÙ±á{¶7AÒ”j…r¸ny-¿¦{7¡gvvy2İ€ a•Ò²jîvBiÓ9N¾l‚ªïõ29ö½3º•g°ƒÉ‘ge¼
ıãÂÚ¤­Ÿªãoå¹£+ŞZ/VL_İÕjï¬^jARÓûo©kïI6ÖæPAj±„¤
ù;^§¿8ş™}ë 7b+I]?¾§tK‡nyÂîR‡Hné’{äÛÆ­ÛsÔ‡’AøXÀôÈÂbµxÒƒ¸M·4cj¯8Ù¿Õ¥‰JÿHõ^}Ç¨3ßŞ‰­Ññ"ö¢•z¡Û‹É'øĞDÁóÅ˜6ÿ|fÃ¿õbÃ$Åh#^¶ùÿâ0Á/µñ-‚‚U]„¡5lvc¸ÿõ¹Ü9@’Å0ÀåH}ó•”ÊÏŒ!lÒƒ2Ä\k´×‰åd@Mú[z„·A4§–•Ëï¨8^\˜z€Ş‘#S]!ÿ¥°(¹U”ä¨EVH-ŒÚbÜOûZA:#qÿ˜XÖ :¿%«$#ùJ³’ì8áÚS[t-Ÿ½•äPòìÍ~W†ˆW[šÆ½¾QV;½o³‘Ïé€Ô"¤¶zßåå7w~™pÑGá‚n’b´ìÜ±¤Sõ~Ò´š}Ñ±e Â»3kŞoê7ôŒ>³®ÑÂP’à“A¿~¯ ,ƒŞ½öˆU\C
ptÏmy-Òˆ¯íëêüù·a™—æïPmO×‹É´0ÿKab”şïÅF´ìà+-zÊEjDàüë/õ•¶‘Qô Zøt—)bÏ~9–s¬¥–ùmH@ÍÄ¶ÿ·.F¯7ƒ> 8C1.6ÓRg®Ş§|¨Dz¬µ´€Ù2®”½Ï !¾u@A»7×¡p›¬_ÕğIZÌêH=,FG‘o¿À9;²‡Yİ-I«[’nO­¥À[o²¥&²Å
’V·‘£œQµôÌ§ok)rd–\[qµËóSçgõë6'aüfUuòN¾:õEx'8dÖv‚vLº_[¡°îÁïò»Íik	„8‚ëèQ¾+fd~b¯8ˆf~K´êglä :~àÉ’ÈSŞb	±§–N	ë*`g]1ïÌ>A¹E»t&fz
ô¥^eGÔ¬Aˆøä±zŠÎZççõx5›Nl‚´Å„Î¾ÿ>Cv^Ÿİ… ’¨eë÷Ö§/¹›”±¡	Âaıƒ1„ÛM3Pˆö—['·¼Hçgê†¥Ğå±³“)0©Ìiıg{ÙAİl¤Ğ?+VæÔÙİië 	¢A\"umhc'´	µÎ”Šæ¼±R‹æ$}×„jêÂ´e¹AjaoƒÅ²ÿ|¹âª÷`«Üï7­§•ŠDHüÅn¹—RCOê«â»iÑjï€\å÷Û€¿¸¨ iZö¥gµTP'5HÛvH-‘T‘£P\è¿Ëõœu¸q+ºüâ÷"#µØDÒ¹ŞJÅÚüe¾'{¼_A==°«ªH#©‰•Z‡í¸C~Uòw!%Òˆ%]P”€7j4^TÓ¼ŸB†K:5¥¶ÙüÉ€§R9glš*\7y.3hñ¥ª)-ìóö5}'NwA£šŞ4¦~TĞ½¥[ Ì£}mÑü_SQ‹º}^Í;­¢Û›P’¯Â>Pa‹‚<ûÚœZlDîŞ>ê
ç$é@Ù‰J3…ÁÄoûœùüb=mA(V=sŠ5äöå7ÿüîA2ÏÀ\a²¦¡ìšÂ+#>”"gA‡®Èjf7~Qa¹¬ğA:l¢…‚ŞÚ,¯‰fG0ÈC¸t…=ë¥g©è2¼UJÛ¡‰BE¦ˆÎ,¨-)3Zföä1‚=»ª+
ùæYKªœgü.™³7S"ñ»+ª¶ ÒŠºå®Ã	Ü-Aíny\±Å~ÛÿB.ša1”o‡!~P+êÏïX†ó;1 *°v7xwQkÅ(½-Ï§%~[0ìş BÆk•·¦¨í|'îû÷Æ®DÂ¨éISkÚ¼æÁ¤Á$u¸n­hX´ıoó]Õ®†îè0µçu•¦·nÈô¸ñm#ü³7z©íïnNî–cĞ_2)ôŸ«mXoî¬È‡ªABì†"İ[ßµi¿‰l©ƒ‚q±»=Ìÿ
JnWİ|øU45gÙ#õ×»;R‹åNÿ!õcöH}D|'ŠÿâŸåş|¬¤wìaøØwVÀVÚ7ÈkH{\ Ô× K°ŞÒCoä×íAÁîâåÊu‚Uç‹°?¥ÜR )W=»#ÕÓ[m¨ÌŞíÈ¡A1¤;¿™ÓE1²İï¶_ë_fKV
(x‚H’Ä6²ğÖ¶
L®çj§5æ€©ÍY¶Ôko™4Ä©øÊî(O¸AWÅ¦°æ/Fµ/íB·ß$µ£§‚:ìJ-<´ÁüÏ<û‚$ıeÕvÔµ#=òÈ¡2›-Fø“4i»6Ê·|÷l£€tÄ²ÿöhËšÌèÁ;  ÉìE7ñIa›­ÙŞã{E?{ "r¬ºSãÅ_£ø÷jD’&rî‰¶5\ÕSåsÛ~Ç(YÌ®K=‘-Oá x×8Ú+ü8ßH”vç¼Ù[´EUOßßóYfÙ„íg I'Yó:½¨Õ×ËñiAñ‚PKšz½¨YÏf~İzÂÔ"ÚÙÕ¯İ[Q¶lô¶Qû¼êöR =ß½k¤F_í€h]·ö¦Öqøp`K>A&¢íšæD}x·—Ve_v‘H-ö8`NÛ(Ş8 ¼ÆÏû(¢Æî¿w¥Êvó3š.¯Ï«‚zèˆöé«€ºùï%ç)ß :¶u´¯bÁâÚæZóò¢C)dÅôÙA"ßõ´_éÂ“„ƒ/¿Rã^pQÔóc¤ağÎq²ëØH¹ğÔ]µ°í½œ;Ú•jÄÊëò1Ö ¤ùæŸ$hğ”OÇ‚ Y;Ö•šõFŞ‰Ü¬ RSƒ)ÉMI®4ûÿ1…ìf©EH/tâa²~ÔU•Ë×ğş'Úö£õ­İ¤>ìJIx~/ô·Ïú)ptxQ¯-lô‚¨¿¥t7· ø;O·ÒŞ²Ïéœ¨&+¹£¿µzÃX›ÙÓ]1ägFÅü¹Kşç‰'H†Õ:I¾›¹îTÔÌ)Lù¨ˆÜ-—İØúUÆoôœH$ÊÜId&ş]É~w‡XÔMyMw ¢«Gzs3­¼H€.Åa õ¢U¿¦ñ†è¸×%8VàE]Àãî¤÷¼©Å)'tĞ‚oRZƒnÔİ•I¹áãÌ’¸‹¬É­ÁTŒ?WŸ•p‹èXÖ³Á”èÆo×æóÊ±Ó¢q2pVø(àWj~oûbö+„hEÒW.C¨AÍ6mYÁæH#vôÁtš!JÙ
îwU+‡Â‚(İnC©Afë-àGªAÁª‰ñÏ(ŞŸ†SHËÍùy¢¿3ŠÛÁ<@ütÅrßÉ«VPe€ğñIë%¢Q'<ÑäR¦@Rmtq¡M@Y •Ù.Y¡Í/6ƒ4"˜¤ıÇQó6bÁ{º  ±N’ªãÍ]i·ªt"Õ§©úÕG@8>ä†áleBZÓ"ğ°ı@ş„—D˜Í#ÜÄÛC¡|ÇİÆ–lK€ÔâI=’ÃI×¢Knœğ®UEKF“tñÉŠ‘§n¼i¶ú°5zrıêMˆzıèÊÁê%bÖvVœ T¸|5TfÍ)ì$I*ìl?”hUïiŠ!\Ö´Ñëõ˜‚¤}LâÏ¦Ss¬¸¡(áş
6wîLÕ::S1àHPÍ—fÏeÛ/`×ïıü”ä8 Õ‘<w¶¢MFX§?Óüş†USµÍ™kx­ãï ‰„²(ÅıÁM¾_ø¡‘}/ütªC&2½àm”âÙ­Õ¯l-ó@ÈŠ²zjQèToªç(ö/ıìŞşšùÙ¨Š.>ı<D™;úŞÁqÑÔ	’_çMÛÎo(JD¾¾£ÑTı²öª¾ìœ ÁKlçÂšŒ!;øîMë¿|l¼Vö@v7Ä)œ®W¬ÿIy™„ !â»±qŠ#fUašÜA“ešÀòvœ%„Ï@D;KPÇºğ(x:w,Ôi¾D´‘íâî¹í_˜Í%›„h:ÇS@×UŞ]( (HXz’—}â<IİGÕ:É›ì µXBÒv·çQYSVlÅ‹‡Øê‰,µ8ŸFÂ3·ƒY¬r@Á›æUzbgV´H±äİ=½Å…ıe®ø†ü~Úô%”Ïº‰4±¼½˜İ‹Oèƒ Inœ¨Ø5òöÈÿä›eIxV¤ıÑ„ ‘îk',¦‰=¬¦z4÷OM*;+ª'dNÛtÅES"Cc^p]Lq«f')'yÌ»9¿wù÷ÓÒˆ¿Ş(`zô2ê×óıç°©…Í`t½ÍVËiFY¡ÿRQ@ä¿ŒJ?¶œìê$ÿáş½¿(Rıv~9Uœ}¹—à!ÒˆøÁ”ê½d2.ï-Ïß!I¦-Iog¤ÒhÉ1èËo;Ÿÿ»Bè»ğFH->ú`kjÍ*ÖÜO†ôVJµBn›¤+^©.xª¦Õ)íc‰Úqš´\ª}#ÒiÊÕšó£O¹ Hv¾N§n“úıdeWªN©³†ÊÖ&x]#^Ò‚„ĞóE§x{i-Ílºé±¹3øŞD¸Bê‹¹¶­nõ™ñ•½x/Dv{/J?¥Ç:J×ªbeG^&‚4¢Ş:Ú=“òë¸xZÎ/H#zA{õÛHp€³A.oÇ‚Ğ^‘z~BÍ6íì_Ü%9H-¶IÒ~âÙ´é³ˆlj›%‡úğZ„r¿û™M9KyñÌBC9#m†ÒÌ|m3åÌG·•s"…ñz³§T;u¯oN­z#†’sÑg•¿¯:Ôã¥áêOÚ¦\™æëæà:Tv–ı‰ØÆx<ÂÏW'Cf‘¿M±tnèpåãÙy¼ìU!§'8÷İFu¼7Ğ.œF‚ 1·ÜNYcšÜ‘²¢ùÚi»B¶+aUëŸƒúĞ^&ø¶¥ÏÔ-­ØNRøäp?¾<"“ãøZ¡kÛÀ‚Ï=°†ç‡¶Ş¼p§"Tïu;ÓêOõÆÑV(w·bıĞå_rß'L¾hßì‘½,±‘ô¯^2{ÑyzÒ·Ï{hôUXçó›ä ©ü‚ÄSkí#qå‚¨/<8AÒJ+ƒÄOßì'±õÕm‡ù(8_¼‘ÄÃeZQktLïÚÉç»sƒ¾ÖCz&°‘İA÷ÈÚe¼¦ı_‚Ã!/ŒşğwbAÿ— ^›}0·×Z³ñÅ1s{Hæ=H*"Çwá’ú<˜%ò™şè4½)üW+–55k[›<Ò 2‡"%°q{úoŞàiÄ{tš¸Œš¨'·Ò˜Í9Â½ßY@­e½xË>J’¦	³át$·ï»æí?ò± Ğá3Ñú:AÒÏú#µØ² !Ú7OP´[®©K9Zm‹PÌÁO*rë¿´³L—ÍAC&ş9Eß•\¼á¤‚n{6mÕ÷ßmO‰ I-9IƒU¿|~WşÂH-üFĞ1ĞÀSŠ¢«ïEİ¶ÔİhÍTÛáÜ¶7"‚Òûi}–&Ã¯ûÜçw‡@ˆÕZs–ìÍ3Ÿ¿ôµ§ô@ÄÜ9«è{Ü¿õ¼¬ŸcOÓËÛ  1b$Y§Ï)p€¤^ùŒ’*
âÜHt&Ù„
“ñŞÛ~(ïàƒ¤9İ5 U×/‘^)Ş4)¯/@¡¢4 ;ôàÀ˜Eì®a'c¼JVÆÈÎSöò#5ãFı_ÕïHÜÈª¤sGadıyv•TÑ¥Û®³Û$•Ò(>c–_/T…Ô}–ü0{3„jp^^HúÆw³wï.lüJD3å·BvO­ë1‘Ÿ¬ ÑòëğhôÖU{Šè›ş[Ë>s‰zÊiwÏ¥Üq@Aâ…Ûü&õÖYß¾u;II‚®Û´›Îìà93J@ja7NÊ‚Í·‹Òõ|R|÷È¦a·Ú.×–ŞÁè0î¶â«ÕÂZB†«¡ë±_ïv¡›Éy¯oSÍy}e7+iPp¡<şòÜ}ZêåÔ^Í/Œ€ÔÂ<Î4‹b
|µ¨ë~(¬Z#éğø“”İöëÍbx=òÅ:<æmœæ{5ı/A¶‹N”YüˆÆĞñ´ÃøË `­øŞc¹¹ÕÅÃı?Ím}mütòd‚<Dßq´y¦(è^Óâ×_]l,êâe“şj‘BÒ·)p#¤â`º_+ŞÈCì"©ãÓJ¸æhŸn|®ä!ªÆaÚ›0ŞW§…Ì²Ís2„ÚN]ÁKkjôÚ¸ç4±ú¥-¾/ı­¥+ôK÷FØ3zğ½4nÄ­3úDU*†P%åË_SÊo§Œ‹á¹„¥ÌÛ	¨—_¯×-öüÈ˜g%›9(Øa^× ÿ€ØC=ºĞ  ©EÄDD<ıõ2[=»İIæÃ6 ´Ô²‰ÈÖçG©¥ZµuåWÉAjá=WQô‰&Hçës>õ¦Â‚Hí¾ÿ¤¸l6ùöeSó’ß€ğÒqò3ç³bÙúÓ]ÿqOiÔ+•ôÌ‡$ñLGÿú¬ÀskË=çõ™A¹IZr%k²á+ÕUºÇèi¯Ø7(ùaÚ”S†69ß¿Å. ïùº[XNÕh¦Ø»‡Ÿğ‰'!ğûi7­TÌ©ZxÄ½üø u¢m5«’&èàŸi­ø5h$IıBé¼Ãâï¤Ö¿5Èç$4¢4ãv ÑE¤·w~;#ÙÓ.4;ñƒN?(¿Yã@á@j¡œ„jX;åU~yãL6~AR5tš„D'7ùISBùM'ş°$H-ÆM‚jKëô“V~óegˆœ1bVfŞÏ«H÷?™ÙYÁGtAä.súEA6-ÙÆé‚°­TH	÷ö›ä%ŸşÀ ©E|©†7¿)Ş•‹µNóU0´r£]î—Õ
ßÂGœ–Õ9ò6?F½°ß,­puÃ¡ª–üCdo*d«„LŸşCk–y³%å‚ÄSVC’­'}ƒNñ½‰¤j
'ÿ÷Àªãı²¹“‚Ôbc8ÚÆÚë/UâŸ)¿.V°OF"DÛxğ_ÊÊQ3¹ µ8B±¾³“)QÇßõÎg*wÂédî-%´ÀÕ®åx™B¬¹ZJØ15ÑwŒùd$»hSŒ—ÛÿâZiÄæÉHïÓ.m%º®aÖ&7>Ç
Å“Ñ–gÕ¢°'z{Ìâí•ªÅ9É_ñO€‚U…ÓLªPâÁO=f%’FËö)f“¼ë(KGÔÛóW÷Ö£MiµÓiC:"}9¥ò“zzÈ•“ÆÒ§EAğbLA^K]ê*éœíË)ìÙ5¦øş»oéøóÜN¾ğòß(Ü«£õ¨."ğNH-úNEKí
©¯„;GÏ;g?-¢£JM(¡Ygº6ÀKZLE1Ætk ¤ó„§ãJÂen@é¥ü]Å«rdÌ¦€‘÷*¿*îkÇŠE‹h+„€ÍC”Ğš	±Ÿ¬ø5ßŒ@w{i D‡ÜÔbL!Ÿ
—¯ÜDP‡Œm¤têòşã™‘'ÍÛ{Ó¿gß¥•´I{&6¦LùëLMà¦‰èÚCĞ„¤Úß¿p–AÈÓ“ùM¨˜*à&ììeˆ(K÷Órê>oW>Ä[× „û!§Ç.ua=’F˜Fûûñ
*jÆKç8ZZä“´C¥c¤ûÈ¤ölƒ4¢¤~*%´bŠéşU¬Aj¡5EÙ”oHagœèğ†·<@´ıØúO²ÙäOì	ãé¨]ã#jjíåË_ŞáÖÁ	=‰.7¢híGê?å‹— Q0ZQYÖ”ê!ÕÜÄ„íHÙfCg W÷+±6yüÇašM— äªÉlc*Í¹Ğ7¿ùe#F„S¸şMšQÄ®Š l”€®nL3ªà—×=×ó‰1ZlšìnØÚŒê×n²l=w%‡8F±®Ò˜*aHå˜Ş4e'6ˆ<·M)Ö1x‡¤ú‘Ğ?İ“›“t·éœ¹üeÂİêi¦Xí¿ãùÇ9äàù2T¾Šµq¸¥µõĞŸy¼gRËHT\PK³‹>ó›œ šNzGÒ}7æJÌ‘/÷•ó»q ±$y“eAÕs·«î.Öë $[xÛ‚;Ø¶>ø-F< ‚xùX*qí»Ï«ıætí„pË-©9–\ç§¤@,|dI#¡dõË
vjƒ‚D«™¾:½e[SÿH¾:ª5çD³|¯Öã–6Bù€’’¯Œí]¥-şzlÕÑ–EW‰ä™°¡>]iC%ˆéİ77ÖAp¬VÍDÍhwmOÑjôÄº<fAÍâ/Í"é›N$¢Ì†ï‚4âÕlHëî¬Äû&rƒß(nv¼QíG÷°UÒ®às3ySD½Ùly„§ØÒHVœùº$H/ŞnÎ¿C­ûşOø¾¨™èód(«ûî/¥ü¢¦¦_4ß½ŞC‰EÈMEüRn ÔÒğ=”¯ÚpümßÎğ/¹>¦‡d9CRşµ‡²m    }
    this.state = "path";
    --this.pointer;
  }

  return true;
};

URLStateMachine.prototype["parse file host"] = function parseFileHost(c, cStr) {
  if (isNaN(c) || c === 47 || c === 92 || c === 63 || c === 35) {
    --this.pointer;
    if (!this.stateOverride && isWindowsDriveLetterString(this.buffer)) {
      this.parseError = true;
      this.state = "path";
    } else if (this.buffer === "") {
      this.url.host = "";
      if (this.stateOverride) {
        return false;
      }
      this.state = "path start";
    } else {
      let host = parseHost(this.buffer, isSpecial(this.url));
      if (host === failure) {
        return failure;
      }
      if (host === "localhost") {
        host = "";
      }
      this.url.host = host;

      if (this.stateOverride) {
        return false;
      }

      this.buffer = "";
      this.state = "path start";
    }
  } else {
    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse path start"] = function parsePathStart(c) {
  if (isSpecial(this.url)) {
    if (c === 92) {
      this.parseError = true;
    }
    this.state = "path";

    if (c !== 47 && c !== 92) {
      --this.pointer;
    }
  } else if (!this.stateOverride && c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (!this.stateOverride && c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else if (c !== undefined) {
    this.state = "path";
    if (c !== 47) {
      --this.pointer;
    }
  }

  return true;
};

URLStateMachine.prototype["parse path"] = function parsePath(c) {
  if (isNaN(c) || c === 47 || (isSpecial(this.url) && c === 92) ||
      (!this.stateOverride && (c === 63 || c === 35))) {
    if (isSpecial(this.url) && c === 92) {
      this.parseError = true;
    }

    if (isDoubleDot(this.buffer)) {
      shortenPath(this.url);
      if (c !== 47 && !(isSpecial(this.url) && c === 92)) {
        this.url.path.push("");
      }
    } else if (isSingleDot(this.buffer) && c !== 47 &&
               !(isSpecial(this.url) && c === 92)) {
      this.url.path.push("");
    } else if (!isSingleDot(this.buffer)) {
      if (this.url.scheme === "file" && this.url.path.length === 0 && isWindowsDriveLetterString(this.buffer)) {
        if (this.url.host !== "" && this.url.host !== null) {
          this.parseError = true;
          this.url.host = "";
        }
        this.buffer = this.buffer[0] + ":";
      }
      this.url.path.push(this.buffer);
    }
    this.buffer = "";
    if (this.url.scheme === "file" && (c === undefined || c === 63 || c === 35)) {
      while (this.url.path.length > 1 && this.url.path[0] === "") {
        this.parseError = true;
        this.url.path.shift();
      }
    }
    if (c === 63) {
      this.url.query = "";
      this.state = "query";
    }
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.

    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += percentEncodeChar(c, isPathPercentEncode);
  }

  return true;
};

URLStateMachine.prototype["parse cannot-be-a-base-URL path"] = function parseCannotBeABaseURLPath(c) {
  if (c === 63) {
    this.url.query = "";
    this.state = "query";
  } else if (c === 35) {
    this.url.fragment = "";
    this.state = "fragment";
  } else {
    // TODO: Add: not a URL code point
    if (!isNaN(c) && c !== 37) {
      this.parseError = true;
    }

    if (c === 37 &&
        (!isASCIIHex(this.input[this.pointer + 1]) ||
         !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    if (!isNaN(c)) {
      this.url.path[0] = this.url.path[0] + percentEncodeChar(c, isC0ControlPercentEncode);
    }
  }

  return true;
};

URLStateMachine.prototype["parse query"] = function parseQuery(c, cStr) {
  if (isNaN(c) || (!this.stateOverride && c === 35)) {
    if (!isSpecial(this.url) || this.url.scheme === "ws" || this.url.scheme === "wss") {
      this.encodingOverride = "utf-8";
    }

    const buffer = new Buffer(this.buffer); // TODO: Use encoding override instead
    for (let i = 0; i < buffer.length; ++i) {
      if (buffer[i] < 0x21 || buffer[i] > 0x7E || buffer[i] === 0x22 || buffer[i] === 0x23 ||
          buffer[i] === 0x3C || buffer[i] === 0x3E) {
        this.url.query += percentEncode(buffer[i]);
      } else {
        this.url.query += String.fromCodePoint(buffer[i]);
      }
    }

    this.buffer = "";
    if (c === 35) {
      this.url.fragment = "";
      this.state = "fragment";
    }
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.buffer += cStr;
  }

  return true;
};

URLStateMachine.prototype["parse fragment"] = function parseFragment(c) {
  if (isNaN(c)) { // do nothing
  } else if (c === 0x0) {
    this.parseError = true;
  } else {
    // TODO: If c is not a URL code point and not "%", parse error.
    if (c === 37 &&
      (!isASCIIHex(this.input[this.pointer + 1]) ||
        !isASCIIHex(this.input[this.pointer + 2]))) {
      this.parseError = true;
    }

    this.url.fragment += percentEncodeChar(c, isC0ControlPercentEncode);
  }

  return true;
};

function serializeURL(url, excludeFragment) {
  let output = url.scheme + ":";
  if (url.host !== null) {
    output += "//";

    if (url.username !== "" || url.password !== "") {
      output += url.username;
      if (url.password !== "") {
        output += ":" + url.password;
      }
      output += "@";
    }

    output += serializeHost(url.host);

    if (url.port !== null) {
      output += ":" + url.port;
    }
  } else if (url.host === null && url.scheme === "file") {
    output += "//";
  }

  if (url.cannotBeABaseURL) {
    output += url.path[0];
  } else {
    for (const string of url.path) {
      output += "/" + string;
    }
  }

  if (url.query !== null) {
    output += "?" + url.query;
  }

  if (!excludeFragment && url.fragment !== null) {
    output += "#" + url.fragment;
  }

  return output;
}

function serializeOrigin(tuple) {
  let result = tuple.scheme + "://";
  result += serializeHost(tuple.host);

  if (tuple.port !== null) {
    result += ":" + tuple.port;
  }

  return result;
}

module.exports.serializeURL = serializeURL;

module.exports.serializeURLOrigin = function (url) {
  // https://url.spec.whatwg.org/#concept-url-origin
  switch (url.scheme) {
    case "blob":
      try {
        return module.exports.serializeURLOrigin(module.exports.parseURL(url.path[0]));
      } catch (e) {
        // serializing an opaque origin returns "null"
        return "null";
      }
    case "ftp":
    case "gopher":
    case "http":
    case "https":
    case "ws":
    case "wss":
      return serializeOrigin({
        scheme: url.scheme,
        host: url.host,
        port: url.port
      });
    case "file":
      // spec says "exercise to the reader", chrome says "file://"
      return "file://";
    default:
      // serializing an opaque origin returns "null"
      return "null";
  }
};

module.exports.basicURLParse = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  const usm = new URLStateMachine(input, options.baseURL, options.encodingOverride, options.url, options.stateOverride);
  if (usm.failure) {
    return "failure";
  }

  return usm.url;
};

module.exports.setTheUsername = function (url, username) {
  url.username = "";
  const decoded = punycode.ucs2.decode(username);
  for (let i = 0; i < decoded.length; ++i) {
    url.username += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.setThePassword = function (url, password) {
  url.password = "";
  const decoded = punycode.ucs2.decode(password);
  for (let i = 0; i < decoded.length; ++i) {
    url.password += percentEncodeChar(decoded[i], isUserinfoPercentEncode);
  }
};

module.exports.serializeHost = serializeHost;

module.exports.cannotHaveAUsernamePasswordPort = cannotHaveAUsernamePasswordPort;

module.exports.serializeInteger = function (integer) {
  return String(integer);
};

module.exports.parseURL = function (input, options) {
  if (options === undefined) {
    options = {};
  }

  // We don't handle blobs, so this just delegates:
  return module.exports.basicURLParse(input, { baseURL: options.baseURL, encodingOverride: options.encodingOverride });
};
